<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>SOLIS Planner</title>
  <link rel="icon" href="https://regnumsolis.com/planner/images/icon.png" type="image/png" />
  <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" />
  <style>
    /* Reset and base styles */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      background: transparent;
      color: white;
      font-family: 'Bebas Neue', sans-serif;
      overflow: hidden;
      position: relative;
    }
    /* Global marker text hover */
    .text-hover-only .marker text,
    .text-hover-only .marker rect {
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .text-hover-only .marker:hover text,
    .text-hover-only .marker:hover rect { opacity: 1; }
    /* Background container */
    #background-container {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
    }
    #waveCanvas { display: block; width: 100%; height: 100%; }
    /* Loading overlay */
    #loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 100;
      display: none; align-items: center; justify-content: center; flex-direction: column; font-size: 2em;
    }
    #loading-overlay img { width: 80px; height: 80px; margin-bottom: 20px; }
    /* Animations */
    @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes neonGlow {
      0% { text-shadow: 0 0 5px rgba(223,197,136,0.6), 0 0 10px rgba(223,197,136,0.6), 0 0 15px rgba(223,197,136,0.6); }
      100% { text-shadow: 0 0 20px rgba(223,197,136,1), 0 0 30px rgba(223,197,136,1), 0 0 40px rgba(223,197,136,1); }
    }
    @keyframes whiteNeonGlow {
      0% { text-shadow: 0 0 2px rgba(255,255,255,0.24), 0 0 4px rgba(255,255,255,0.24), 0 0 6px rgba(255,255,255,0.24); }
      100% { text-shadow: 0 0 8px rgba(255,255,255,0.4), 0 0 12px rgba(255,255,255,0.4), 0 0 16px rgba(255,255,255,0.4); }
    }
    @keyframes reducedNeonGlow {
      0% { text-shadow: 0 0 2px rgba(223,197,136,0.24), 0 0 4px rgba(223,197,136,0.24), 0 0 6px rgba(223,197,136,0.24); }
      100% { text-shadow: 0 0 8px rgba(223,197,136,0.4), 0 0 12px rgba(223,197,136,0.4), 0 0 16px rgba(223,197,136,0.4); }
    }
    @keyframes swing { 0% { transform: rotate(-10deg); } 50% { transform: rotate(10deg); } 100% { transform: rotate(-10deg); } }
    .drag-clone { animation: swing 1s ease-in-out infinite; opacity: 0.9; }
    /* Paint Bucket Container */
    #paint-bucket-container {
      position: fixed;
      top: 140px;
      left: 20px;
      width: 50px;
      height: 50px;
      z-index: 25;
      cursor: pointer;
    }
    #paint-bucket-container:hover::after {
      content: "change color";
      position: absolute;
      top: -25px;
      left: 0;
      background: rgba(30,30,30,0.9);
      padding: 3px 6px;
      border-radius: 3px;
      font-family: Arial, sans-serif;
      font-size: 0.9em;
      color: #dfc588;
      white-space: nowrap;
    }
    /* Paint bucket SVG styling */
    #paint-bucket-svg {
      width: 100%;
      height: 100%;
    }
    /* Color Picker Modal */
    #color-picker-modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30,30,30,0.95);
      border: 1px solid rgba(223,197,136,0.8);
      border-radius: 8px;
      padding: 20px;
      z-index: 3000;
    }
    #color-picker-modal h3 {
      text-align: center;
      margin-bottom: 10px;
      font-family: Arial, sans-serif;
    }
    #color-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 5px;
    }
    .color-cell {
      width: 30px;
      height: 30px;
      border: 1px solid #1e1e1e;
      cursor: pointer;
      border-radius: 4px;
    }
    /* Modal close button */
    #color-picker-close {
      margin-top: 10px;
      display: block;
      width: 100%;
      padding: 8px;
      background: rgba(223,197,136,0.8);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: Arial, sans-serif;
    }
    /* Login screen */
    #login-screen {
      display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;
      background: rgba(30,30,30,0.9); animation: fadeIn 1s ease-out; text-align: center; position: relative; z-index: 1;
    }
    #login-screen h2 { font-size: 3em; margin-bottom: 20px; animation: neonGlow 1.5s infinite alternate ease-in-out; }
    #login-screen input {
      margin: 5px; padding: 10px; font-size: 1.2em; width: 250px; border: none; border-radius: 4px; text-align: center;
    }
    #login-screen button {
      margin-top: 10px; padding: 10px 20px; font-size: 1.2em; border: none; border-radius: 4px;
      background: rgba(223,197,136,0.8); color: white; cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s; box-shadow: 0 4px 15px rgba(223,197,136,0.5);
    }
    #login-screen button:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(223,197,136,0.9); }
    #login-error { margin-top: 10px; color: #e74c3c; font-weight: bold; }
    /* Main app container */
    #app { display: none; height: 100vh; position: relative; animation: fadeIn 1s ease-out; z-index: 1; }
    /* Header */
    #header-logo { text-align: center; padding: 10px 0; background: transparent; }
    #header-logo h1 {
      font-size: 1.05em;
      margin: 0;
      color: white;
      animation: whiteNeonGlow 1.5s infinite alternate ease-in-out;
    }
    /* Right menus */
    #right-menus { position: fixed; top: 100px; right: 20px; display: flex; flex-direction: column; gap: 20px; z-index: 20; }
    .menu-container {
      width: 180px; background: rgba(30,30,30,0.9); padding: 10px; border: 1px solid rgba(223,197,136,0.5);
      border-radius: 5px; box-shadow: 0 0 10px rgba(223,197,136,0.5); position: relative; transition: transform 0.3s ease;
    }
    .menu-container.hidden { transform: translateX(109%); }
    .menu-header { display: flex; align-items: center; justify-content: center; font-size: 1.2em; margin-bottom: 5px; position: relative; }
    .menu-toggle {
      position: absolute; left: -45px; top: -40%; background: none; border: none; font-size: 1.05em;
      color: rgb(223,197,136); cursor: pointer; padding: 0; line-height: 1; width: 22px !important; height: 23px !important; z-index: 100; pointer-events: auto;
    }
    .menu-content { display: flex; flex-direction: column; gap: 5px; }
    .menu-content button {
      width: 100%; height: 40px; border: none; border-radius: 4px; background: rgba(223,197,136,0.8);
      color: white; cursor: pointer; transition: transform 0.3s, box-shadow 0.3s; box-shadow: 0 4px 15px rgba(223,197,136,0.5);
    }
    .menu-content button:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(223,197,136,0.9); }
    #text-toggle-right h2 { font-size: 1em; margin-bottom: 5px; }
    .toggle-switch {
      appearance: none; -webkit-appearance: none; width: 40px; height: 20px; background: #ccc; border-radius: 20px;
      position: relative; outline: none; cursor: pointer; transition: background 0.3s;
    }
    .toggle-switch:checked { background: #dfc588; }
    .toggle-switch::before {
      content: ""; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: white; border-radius: 50%;
      transition: transform 0.3s;
    }
    .toggle-switch:checked::before { transform: translateX(20px); }
    #toggle-container { display: flex; align-items: center; justify-content: center; }
    #toggle-marker-text-label { margin-left: 10px; line-height: 20px; }
    /* Override switch label fonts to use normal sans-serif */
    #text-toggle-right .menu-content label {
      font-family: Arial, sans-serif;
    }
    /* Update the marker visibility toggles to use "keep" instead of "citadel" */
    #marker-visibility-container { margin-top: 10px; text-align: left; width: 100%; }
    #marker-visibility-container h3 { font-size: 0.9em; margin-bottom: 5px; text-align: center; }
    .toggle-item { display: flex; justify-content: space-between; align-items: center; margin: 3px 0; }
    .toggle-item label { font-size: 0.85em; flex-grow: 1; margin-left: 5px; }
    /* Toolbox */
    #toolbox {
      position: fixed; top: 180px; left: 20px; background: rgba(30,30,30,0.9); padding: 10px;
      border: 1px solid rgba(223,197,136,0.5); border-radius: 5px; box-shadow: 0 0 10px rgba(223,197,136,0.5); z-index: 20;
      display: flex; flex-direction: column; gap: 10px;
    }
    /* Individual tool tooltip styling */
    .tool {
      position: relative;
      width: 50px; height: 50px; border: 1px solid rgba(223,197,136,0.5); background: rgba(30,30,30,0.9);
      display: flex; align-items: center; justify-content: center; cursor: pointer; border-radius: 5px; transition: transform 0.3s, border-color 0.3s;
    }
    .tool:hover { transform: scale(1.1); }
    .tool img { max-width: 100%; max-height: 100%; }
    .tool::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 50%;
      left: 105%;
      transform: translateY(-50%);
      white-space: nowrap;
      background: transparent;
      color: white;
      font-family: 'Bebas Neue', sans-serif;
      font-size: 1em;
      opacity: 0;
      pointer-events: none;
      animation: whiteNeonGlow 1.5s infinite alternate ease-in-out;
      transition: opacity 0.3s ease;
    }
    .tool:hover::after {
      opacity: 1;
    }
    /* Map container */
    #map-container { width: 100vw; height: calc(100vh - 60px); overflow: hidden; }
    #map-svg-container { width: 100%; height: 100%; }
    .marker:hover { opacity: 0.8; cursor: pointer; }
    /* Error overlay */
    #error-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(30,30,30,0.95);
      color: #ecf0f1; display: none; align-items: center; justify-content: center; z-index: 50; font-size: 1.5em; text-align: center; padding: 20px;
    }
    /* New Admin Panel */
    #admin-panel {
      position: fixed; bottom: 20px; right: 20px; width: 320px; background: rgba(30,30,30,0.9);
      border: 1px solid rgba(223,197,136,0.5); border-radius: 5px; box-shadow: 0 0 10px rgba(223,197,136,0.5);
      z-index: 30; display: none; animation: fadeIn 1s ease-out;
    }
    #admin-panel header {
      display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid rgba(223,197,136,0.5);
      background: rgba(30,30,30,0.95);
    }
    #admin-panel header h3 { margin: 0; font-size: 1.8em; }
    #admin-panel header .admin-controls button {
      background: none; border: none; font-size: 1.2em; color: rgb(223,197,136); cursor: pointer; margin-left: 5px;
    }
    #audit-log-container { max-height: 200px; overflow-y: auto; padding: 10px; font-size: 1.2em; }
    #audit-log-container div { margin-bottom: 5px; }
    .log-user { color: #dfc588; font-weight: bold; }
    .log-action { color: #8ac6d1; }
    .log-group { color: #dfc588; }
    #admin-panel footer {
      display: flex; justify-content: space-around; padding: 10px; border-top: 1px solid rgba(223,197,136,0.5);
      background: rgba(30,30,30,0.95);
    }
    #admin-panel footer button {
      padding: 8px 12px; font-size: 1em; border: none; border-radius: 4px; background: rgba(223,197,136,0.8);
      color: white; cursor: pointer; transition: transform 0.3s, box-shadow 0.3s;
    }
    #admin-panel footer button:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(223,197,136,0.9); }
    /* Footer styles */
    #footer-info {
      position: fixed;
      bottom: 0;
      width: calc(100% - 40px);
      left: 20px;
      background: transparent;
      text-align: center;
      padding: 10px 0;
      font-size: 1em;
      animation: whiteNeonGlow 1.5s infinite alternate ease-in-out;
      z-index: 10;
    }
    #footer-info p {
      margin: 0;
      display: inline;
    }
    #footer-info a {
      color: white;
      text-decoration: underline;
      margin-left: 5px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Animated waves background using WebGL -->
  <div id="background-container">
    <canvas id="waveCanvas"></canvas>
  </div>

  <!-- Loading overlay -->
  <div id="loading-overlay">
    <img src="https://regnumsolis.com/planner/images/loading.gif" alt="Loading" />
    <div id="loading-text">0%</div>
  </div>

  <!-- Paint Bucket Icon -->
  <div id="paint-bucket-container">
    <svg id="paint-bucket-svg" viewBox="0 0 64 64">
      <!-- Bucket outline -->
      <path d="M12 20 L52 20 L44 50 L20 50 Z" stroke="white" stroke-width="2" fill="none" />
      <!-- Paint inside the bucket -->
      <rect id="paint-fill" x="16" y="24" width="32" height="12" fill="#dfc588" />
    </svg>
  </div>

  <!-- Color Picker Modal -->
  <div id="color-picker-modal">
    <h3>Select a Color</h3>
    <div id="color-grid"></div>
    <button id="color-picker-close">Close</button>
  </div>

  <!-- Login Screen -->
  <div id="login-screen">
    <h2>Login</h2>
    <input id="email" type="email" placeholder="Email" />
    <input id="password" type="password" placeholder="Password" />
    <button id="login-button">Login</button>
    <div id="login-error"></div>
  </div>

  <!-- Main App -->
  <div id="app">
    <!-- Header -->
    <div id="header-logo">
      <h1>Regnum Solis Research and Development for the Remnant Senate</h1>
    </div>

    <!-- Right-side menus container -->
    <div id="right-menus">
      <!-- Map Change Menu -->
      <div id="map-change-container" class="menu-container hidden">
        <div class="menu-header">
          <span>Change Maps</span>
          <button class="menu-toggle">&#9654;</button>
        </div>
        <div class="menu-content">
          <button id="tactical-map">Tactical Map</button>
          <button id="style-map">Style Map</button>
        </div>
      </div>

      <!-- Zoom Controls -->
      <div id="zoom-controls" class="menu-container hidden">
        <div class="menu-header">
          <span>Zoom</span>
          <button class="menu-toggle">&#9654;</button>
        </div>
        <div class="menu-content">
          <button id="zoom-in">Zoom In</button>
          <button id="zoom-out">Zoom Out</button>
          <button id="reset-zoom">Reset</button>
        </div>
      </div>

      <!-- Settings -->
      <div id="text-toggle-right" class="menu-container hidden">
        <div class="menu-header">
          <span>Settings</span>
          <button class="menu-toggle">&#9654;</button>
        </div>
        <div class="menu-content">
          <div id="toggle-container">
            <input type="checkbox" id="toggle-marker-text" class="toggle-switch" />
            <label for="toggle-marker-text" id="toggle-marker-text-label">Text on Hover</label>
          </div>
          <div id="marker-visibility-container">
            <h3>Marker Visibility</h3>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-homestead" class="toggle-switch" checked />
              <label for="toggle-homestead">Homestead</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-keep" class="toggle-switch" checked />
              <label for="toggle-keep">Keep</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-torch" class="toggle-switch" checked />
              <label for="toggle-torch">Torch</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-cave" class="toggle-switch" checked />
              <label for="toggle-cave">Cave</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-sword" class="toggle-switch" checked />
              <label for="toggle-sword">Sword</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-spear" class="toggle-switch" checked />
              <label for="toggle-spear">Spear</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-bow" class="toggle-switch" checked />
              <label for="toggle-bow">Bow</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-beacon" class="toggle-switch" checked />
              <label for="toggle-beacon">Beacon</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-camp" class="toggle-switch" checked />
              <label for="toggle-camp">Camp</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-catapult" class="toggle-switch" checked />
              <label for="toggle-catapult">Catapult</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-ram" class="toggle-switch" checked />
              <label for="toggle-ram">Ram</label>
            </div>
            <div class="toggle-item">
              <input type="checkbox" id="toggle-lines" class="toggle-switch" checked />
              <label for="toggle-lines">Lines</label>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Toolbox -->
    <div id="toolbox">
      <!-- Existing Line Tool -->
      <div class="tool" data-type="line" data-tooltip="Draw Line">
        <img src="https://regnumsolis.com/planner/images/line.svg" alt="Line Draw" onerror="this.onerror=null;this.src='data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2250%22 height=%2250%22><text x=%220%22 y=%2230%22 fill=%22white%22 font-size=%2230%22>―</text></svg>'" />
      </div>
      <!-- New Bezier Tool -->
      <div class="tool" data-type="bezier" data-tooltip="Draw Bezier Curve">
        <svg width="50" height="50" viewBox="0 0 50 50">
          <path d="M10 40 Q25 10 40 40" stroke="white" stroke-width="3" fill="none" />
        </svg>
      </div>
      <!-- New Polygon Tool -->
      <div class="tool" data-type="polygon" data-tooltip="Draw Polygon">
        <svg width="50" height="50" viewBox="0 0 50 50">
          <polygon points="25,10 10,40 40,40" stroke="white" stroke-width="3" fill="none" />
        </svg>
      </div>
      <!-- Other existing tools -->
      <div class="tool" draggable="true" data-type="torch" data-tooltip="Place Torch">
        <img src="https://regnumsolis.com/planner/images/torch.svg" alt="Torch" />
      </div>
      <div class="tool" draggable="true" data-type="keep" data-tooltip="Place Keep">
        <img src="https://regnumsolis.com/planner/images/citadel.svg" alt="Keep" />
      </div>
      <div class="tool" draggable="true" data-type="homestead" data-tooltip="Place Homestead">
        <img src="https://regnumsolis.com/planner/images/marker.svg" alt="Homestead" />
      </div>
      <div class="tool" draggable="true" data-type="camp" data-tooltip="Place Camp">
        <img src="https://regnumsolis.com/planner/images/camp.svg" alt="Camp" />
      </div>
      <div class="tool" draggable="true" data-type="beacon" data-tooltip="Place Beacon">
        <img src="https://regnumsolis.com/planner/images/beacon.svg" alt="Beacon" />
      </div>
      <div class="tool" draggable="true" data-type="cave" data-tooltip="Place Cave">
        <img src="https://regnumsolis.com/planner/images/cave.svg" alt="Cave" />
      </div>
      <div class="tool" draggable="true" data-type="sword" data-tooltip="Place Sword">
        <img src="https://regnumsolis.com/planner/images/sword.svg" alt="Sword" />
      </div>
      <div class="tool" draggable="true" data-type="spear" data-tooltip="Place Spear">
        <img src="https://regnumsolis.com/planner/images/spear.svg" alt="Spear" />
      </div>
      <div class="tool" draggable="true" data-type="bow" data-tooltip="Place Bow">
        <img src="https://regnumsolis.com/planner/images/bow.svg" alt="Bow" />
      </div>
      <div class="tool" draggable="true" data-type="catapult" data-tooltip="Place Catapult">
        <img src="https://regnumsolis.com/planner/images/catapult.svg" alt="Catapult" />
      </div>
      <div class="tool" draggable="true" data-type="ram" data-tooltip="Place Ram">
        <img src="https://regnumsolis.com/planner/images/ram.svg" alt="Ram" />
      </div>
    </div>

    <!-- Map Container -->
    <div id="map-container">
      <div id="map-svg-container"></div>
    </div>

    <!-- New Admin Panel (only for admin users) -->
    <div id="admin-panel">
      <header>
        <h3>Admin Panel</h3>
        <div class="admin-controls">
          <button id="minimize-panel" title="Minimize/Maximize">➖</button>
          <button id="copy-log" title="Copy Audit Log">📋</button>
          <button id="clear-logs" title="Delete All Audit Logs">🗑️</button>
        </div>
      </header>
      <div id="audit-log-container"></div>
      <footer>
        <button id="delete-all-markers">Delete All Markers</button>
      </footer>
    </div>
  </div>

  <!-- Footer -->
  <footer id="footer-info">
    <p>
      Build version: v1.10.4rc |
      Encrypted database connection: <span id="db-connection-status">🟢</span> |
      Status: <span id="user-status">user</span> |
      <a href="https://regnumsolis.com">Return to Home</a>
    </p>
  </footer>

  <div id="error-overlay">Database connection failed. The app cannot be used at this time.</div>

  <!-- Custom Prompt Modal -->
  <div id="custom-prompt-overlay" style="display:none; position: fixed; top: 0; left: 0; width:100%; height:100%; background: rgba(0,0,0,0.5); backdrop-filter: blur(5px); align-items: center; justify-content: center; z-index: 2000;">
    <div id="custom-prompt" style="background: #1e1e1e; border: 1px solid rgba(223,197,136,0.8); padding: 20px; border-radius: 8px; color: white; min-width: 300px; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center;">
      <p id="custom-prompt-message" style="margin-bottom: 15px; width:100%;"></p>
      <input id="custom-prompt-input" type="text" style="width: 80%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 15px; text-align: center;" />
      <div style="display: flex; justify-content: center; gap: 10px; width: 100%;">
        <button id="custom-prompt-ok" style="padding: 8px 15px; background: rgba(223,197,136,0.8); border: none; border-radius: 4px; cursor: pointer;">OK</button>
        <button id="custom-prompt-cancel" style="padding: 8px 15px; background: rgba(223,197,136,0.8); border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getFirestore, collection, addDoc, orderBy, query, onSnapshot, deleteDoc, doc, serverTimestamp, getDocs, getDoc } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
    import { getAuth, signInWithEmailAndPassword, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";

    // Global selected color for tools. Default is set to "#dfc588"
    let selectedColor = "#dfc588";

    const firebaseConfig = {
      apiKey: "AIzaSyAIws_FKV_CTaiHdnwc8WigDqRkyUCOjtE",
      authDomain: "regnum-d3ddf.firebaseapp.com",
      projectId: "regnum-d3ddf",
      storageBucket: "regnum-d3ddf.firebasestorage.app",
      messagingSenderId: "565532905074",
      appId: "1:565532905074:web:a4cc38363376e49540fceb",
      measurementId: "G-4RG5NP4FZ3"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    let panZoomInstance, svgRoot, panLayer, lineLayer, markerLayer;
    let isMapReady = false;
    let activeTool = null;
    let lineDrawingState = 0;
    let currentLine = null;
    let currentLineGroup = null;

    // Globals for Bezier and Polygon tools
    let bezierControlPoints = [];
    let polygonVertices = [];
    let currentBezierPath = null;
    let currentPolygonElement = null;

    // Global visibility state
    const visibilityState = {
      homestead: true, keep: true, torch: true, cave: true,
      sword: true, spear: true, bow: true, beacon: true,
      camp: true, catapult: true, ram: true, lines: true
    };

    function updateMarkerVisibility() {
      markerLayer.querySelectorAll("[data-marker='true']").forEach(markerEl => {
        const type = markerEl.getAttribute("data-type");
        markerEl.style.display = visibilityState[type] ? "" : "none";
      });
    }
    function updateLineVisibility() {
      lineLayer.style.display = visibilityState.lines ? "" : "none";
    }

    let loadingInterval;
    let currentProgress = 0;
    const loadingOverlay = document.getElementById("loading-overlay");
    const loadingText = document.getElementById("loading-text");

    document.addEventListener("DOMContentLoaded", () => {
      setupLogin();
      setupToolbox();
      setupMapSwitchControls();
      setupMenuToggles();
      setupAdminPanelControls();
      setupColorPicker();

      const toggleMarkerTextCheckbox = document.getElementById("toggle-marker-text");
      const toggleLabel = document.getElementById("toggle-marker-text-label");
      toggleMarkerTextCheckbox.addEventListener("change", function() {
        if (this.checked) {
          document.body.classList.add("text-hover-only");
          toggleLabel.textContent = "Text on Hover";
        } else {
          document.body.classList.remove("text-hover-only");
          toggleLabel.textContent = "All Text Active";
        }
      });

      Object.keys(visibilityState).forEach(key => {
        const checkbox = document.getElementById(`toggle-${key}`);
        if (checkbox) {
          checkbox.addEventListener("change", function() {
            visibilityState[key] = this.checked;
            if (key === "lines") updateLineVisibility();
            else updateMarkerVisibility();
          });
        }
      });
    });

    function setupColorPicker() {
      // Populate the color grid with 64 default colors
      const colorGrid = document.getElementById("color-grid");
      const defaultColors = [
        "#FF6633","#FFB399","#FF33FF","#FFFF99","#00B3E6","#E6B333","#3366E6","#999966",
        "#99FF99","#B34D4D","#80B300","#809900","#E6B3B3","#6680B3","#66991A","#FF99E6",
        "#CCFF1A","#FF1A66","#E6331A","#33FFCC","#66994D","#B366CC","#4D8000","#B33300",
        "#CC80CC","#66664D","#991AFF","#E666FF","#4DB3FF","#1AB399","#E666B3","#33991A",
        "#CC9999","#B3B31A","#00E680","#4D8066","#809980","#E6FF80","#1AFF33","#999933",
        "#FF3380","#CCCC00","#66E64D","#4D80CC","#9900B3","#E64D66","#4DB380","#FF4D4D",
        "#99E6E6","#6666FF","#FF6666","#FF9933","#FFCC33","#CCCC33","#99CC33","#66CC33",
        "#33CC33","#33CC66","#33CC99","#33CCCC","#3399CC","#3366CC","#3333CC","#6633CC"
      ];
      defaultColors.forEach(color => {
        const cell = document.createElement("div");
        cell.className = "color-cell";
        cell.style.backgroundColor = color;
        cell.addEventListener("click", () => {
          selectedColor = color;
          document.getElementById("paint-fill").setAttribute("fill", selectedColor);
          closeColorPicker();
        });
        colorGrid.appendChild(cell);
      });

      document.getElementById("paint-bucket-container").addEventListener("click", openColorPicker);
      document.getElementById("color-picker-close").addEventListener("click", closeColorPicker);
    }

    function openColorPicker() {
      document.getElementById("color-picker-modal").style.display = "block";
    }

    function closeColorPicker() {
      document.getElementById("color-picker-modal").style.display = "none";
    }

    function setupMenuToggles() {
      document.querySelectorAll(".menu-toggle").forEach(btn => {
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const menu = btn.closest(".menu-container");
          menu.classList.toggle("hidden");
          btn.innerHTML = menu.classList.contains("hidden") ? "&#9654;" : "&#9664;";
        });
      });
    }

    function setupAdminPanelControls() {
      const minimizeBtn = document.getElementById("minimize-panel");
      const auditContainer = document.getElementById("audit-log-container");
      let isMinimized = false;
      minimizeBtn.addEventListener("click", () => {
        if (!isMinimized) {
          auditContainer.style.display = "none";
          minimizeBtn.textContent = "➕";
          isMinimized = true;
        } else {
          auditContainer.style.display = "block";
          minimizeBtn.textContent = "➖";
          isMinimized = false;
        }
      });

      document.getElementById("copy-log").addEventListener("click", () => {
        let logText = "";
        auditContainer.querySelectorAll("div").forEach(entry => {
          logText += entry.innerText + "\n";
        });
        navigator.clipboard.writeText(logText);
      });

      document.getElementById("clear-logs").addEventListener("click", async () => {
        if (confirm("Delete all audit logs?")) {
          try {
            const auditSnapshot = await getDocs(collection(db, "auditLogs"));
            auditSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "auditLogs", docSnap.id));
            });
          } catch (error) {
            console.error("Error deleting audit logs:", error);
          }
        }
      });

      document.getElementById("delete-all-markers").addEventListener("click", async () => {
        if (confirm("Delete all markers?")) {
          try {
            const markersSnapshot = await getDocs(collection(db, "markers"));
            markersSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "markers", docSnap.id));
            });
            const linesSnapshot = await getDocs(collection(db, "lines"));
            linesSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "lines", docSnap.id));
            });
            const bezierSnapshot = await getDocs(collection(db, "bezierCurves"));
            bezierSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "bezierCurves", docSnap.id));
            });
            const polygonsSnapshot = await getDocs(collection(db, "polygons"));
            polygonsSnapshot.forEach(async (docSnap) => {
              await deleteDoc(doc(db, "polygons", docSnap.id));
            });
          } catch (error) {
            console.error("Error deleting markers:", error);
          }
        }
      });
    }

    function showLoading() {
      currentProgress = 0;
      loadingText.textContent = "0%";
      loadingOverlay.style.display = "flex";
      loadingInterval = setInterval(() => {
        if (currentProgress < 90) {
          currentProgress += Math.floor(Math.random() * 3) + 1;
          if (currentProgress > 90) currentProgress = 90;
          loadingText.textContent = currentProgress + "%";
        }
      }, 100);
    }

    function hideLoading() {
      clearInterval(loadingInterval);
      loadingText.textContent = "100%";
      setTimeout(() => { loadingOverlay.style.display = "none"; }, 300);
      document.getElementById("db-connection-status").textContent = "🟢";
    }

    function setupLogin() {
      document.getElementById("login-button").addEventListener("click", () => {
        const email = document.getElementById("email").value.trim();
        const password = document.getElementById("password").value.trim();
        const errorDiv = document.getElementById("login-error");

        signInWithEmailAndPassword(auth, email, password)
          .then(() => {
            errorDiv.textContent = "";
            document.getElementById("login-screen").style.display = "none";
            document.getElementById("app").style.display = "block";
            initializeMap();
          })
          .catch((error) => { errorDiv.textContent = error.message; });
      });

      onAuthStateChanged(auth, (user) => {
        if (user) {
          document.getElementById("login-screen").style.display = "none";
          document.getElementById("app").style.display = "block";
          initializeMap();
          getDoc(doc(db, "admins", user.email))
            .then((docSnap) => {
              if (docSnap.exists()) {
                document.getElementById("admin-panel").style.display = "block";
                document.getElementById("user-status").textContent = "admin";
                listenForAuditLogs();
              } else {
                console.log("User is not an admin according to Firestore");
                document.getElementById("user-status").textContent = "user";
              }
            })
            .catch((err) => console.error("Error checking admin status:", err));
        } else {
          document.getElementById("login-screen").style.display = "flex";
          document.getElementById("app").style.display = "none";
        }
      });
    }

    function initializeMap() { 
      switchMap("https://regnumsolis.com/planner/images/mvmvmdfs.svg");
    }

    function switchMap(url) {
      if (panZoomInstance) { panZoomInstance.destroy(); }
      isMapReady = false;
      const container = document.getElementById("map-svg-container");
      showLoading();
      fetch(url)
        .then(response => response.text())
        .then(svgText => {
          container.innerHTML = svgText;
          setupPanZoomLayers();
          setupZoomControls();
          setupDragAndDrop();
          setupDrawingTools();
          listenForMarkers();
          listenForLines();
          listenForBezierCurves();
          listenForPolygons();
          isMapReady = true;
          hideLoading();
        })
        .catch(error => {
          console.error("Error loading SVG:", error);
          displayErrorOverlay("Error loading map data.");
          hideLoading();
          document.getElementById("db-connection-status").textContent = "🔴";
        });
    }

    function setupMapSwitchControls() {
      document.getElementById("tactical-map").addEventListener("click", () => {
        switchMap("https://regnumsolis.com/planner/images/mvmvmdfstactical.svg");
      });
      document.getElementById("style-map").addEventListener("click", () => {
        switchMap("https://regnumsolis.com/planner/images/mvmvmdfs.svg");
      });
    }

    function setupPanZoomLayers() {
      svgRoot = document.getElementById("map-svg-container").querySelector("svg");
      svgRoot.setAttribute("width", "100%");
      svgRoot.setAttribute("height", "100%");
      svgRoot.setAttribute("preserveAspectRatio", "xMidYMid meet");

      panLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
      panLayer.id = "pan-layer";
      while (svgRoot.firstChild) { panLayer.appendChild(svgRoot.firstChild); }
      svgRoot.appendChild(panLayer);

      lineLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
      lineLayer.id = "line-layer";
      panLayer.appendChild(lineLayer);

      markerLayer = document.createElementNS("http://www.w3.org/2000/svg", "g");
      markerLayer.id = "marker-layer";
      panLayer.appendChild(markerLayer);

      panZoomInstance = svgPanZoom(svgRoot, {
        zoomEnabled: true, panEnabled: true, controlIconsEnabled: false, minZoom: 0.5, maxZoom: 5,
        beforeMouseDown: function(e) {
          if (activeTool === "line" || activeTool === "bezier" || activeTool === "polygon") return false;
          if (e.target.getAttribute("data-marker") === "true" ||
              (e.target.parentNode && e.target.parentNode.getAttribute("data-marker") === "true")) { return false; }
          return true;
        }
      });
    }

    function setupZoomControls() {
      document.getElementById("zoom-in").addEventListener("click", () => panZoomInstance.zoomIn());
      document.getElementById("zoom-out").addEventListener("click", () => panZoomInstance.zoomOut());
      document.getElementById("reset-zoom").addEventListener("click", () => panZoomInstance.resetZoom());
    }

    function setupToolbox() {
      document.querySelectorAll("#toolbox .tool").forEach((tool) => {
        const type = tool.dataset.type;
        if (type === "line") {
          tool.addEventListener("click", () => {
            activeTool = "line";
            lineDrawingState = 0;
            document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
            tool.style.borderColor = "red";
          });
        } else if (type === "bezier") {
          tool.addEventListener("click", () => {
            activeTool = "bezier";
            bezierControlPoints = [];
            if (currentBezierPath) { currentBezierPath.remove(); currentBezierPath = null; }
            markerLayer.style.pointerEvents = "none";
            document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
            tool.style.borderColor = "red";
          });
        } else if (type === "polygon") {
          tool.addEventListener("click", () => {
            activeTool = "polygon";
            polygonVertices = [];
            if (currentPolygonElement) { currentPolygonElement.remove(); currentPolygonElement = null; }
            markerLayer.style.pointerEvents = "none";
            document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
            tool.style.borderColor = "red";
          });
        } else {
          tool.addEventListener("dragstart", (e) => {
            e.dataTransfer.setData("text/plain", type);
            const emptyImg = new Image();
            emptyImg.src = "data:image/svg+xml;charset=utf-8,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
            e.dataTransfer.setDragImage(emptyImg, 0, 0);
            const dragClone = tool.cloneNode(true);
            dragClone.classList.add("drag-clone");
            dragClone.style.position = "fixed";
            dragClone.style.top = "0px";
            dragClone.style.left = "0px";
            dragClone.style.pointerEvents = "none";
            dragClone.style.zIndex = "1000";
            document.body.appendChild(dragClone);
            tool.dragClone = dragClone;
          });
          tool.addEventListener("drag", (e) => {
            if (!tool.dragClone) return;
            const offsetX = 10;
            const offsetY = 10;
            tool.dragClone.style.left = e.clientX + offsetX + "px";
            tool.dragClone.style.top = e.clientY + offsetY + "px";
          });
          tool.addEventListener("dragend", (e) => {
            if (tool.dragClone) {
              tool.dragClone.remove();
              tool.dragClone = null;
            }
          });
        }
      });
    }
    document.addEventListener("dragover", (e) => {
      const activeClone = document.querySelector(".drag-clone");
      if (activeClone) {
        activeClone.style.left = (e.clientX + 10) + "px";
        activeClone.style.top = (e.clientY + 10) + "px";
      }
    });

    function setupDragAndDrop() {
      svgRoot.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
      });

      svgRoot.addEventListener("drop", async (e) => {
        if (!isMapReady || activeTool === "line" || activeTool === "bezier" || activeTool === "polygon") return;
        e.preventDefault();
        const type = e.dataTransfer.getData("text/plain");
        const cursorPos = getSVGPoint(e);
        await addMarkerToFirestore(type, cursorPos.x, cursorPos.y);
      });
    }

    // Combined drawing tool event listener for line, bezier and polygon
    function setupDrawingTools() {
      svgRoot.removeEventListener("click", drawingToolHandler);
      svgRoot.addEventListener("click", drawingToolHandler);
      svgRoot.addEventListener("contextmenu", (e) => {
        if (activeTool === "bezier") {
          e.preventDefault();
          commitBezier();
        } else if (activeTool === "polygon") {
          e.preventDefault();
          commitPolygon();
        }
      });
    }

    async function drawingToolHandler(e) {
      const pt = getSVGPoint(e);
      if (activeTool === "line") {
        if (lineDrawingState === 0) {
          currentLineGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
          currentLineGroup.classList.add("line-group");
          // Use selectedColor instead of prompting for color
          const lineColor = selectedColor;
          currentLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
          currentLine.setAttribute("x1", pt.x);
          currentLine.setAttribute("y1", pt.y);
          currentLine.setAttribute("x2", pt.x);
          currentLine.setAttribute("y2", pt.y);
          currentLine.setAttribute("stroke-width", "3.2");
          currentLine.setAttribute("stroke", lineColor);
          currentLineGroup.startPoint = { x: pt.x, y: pt.y };
          currentLineGroup.lineColor = lineColor;
          currentLineGroup.appendChild(currentLine);
          lineLayer.appendChild(currentLineGroup);
          lineDrawingState = 1;
        } else if (lineDrawingState === 1) {
          const x1 = currentLineGroup.startPoint.x;
          const y1 = currentLineGroup.startPoint.y;
          const x2 = pt.x;
          const y2 = pt.y;
          currentLine.setAttribute("x2", x2);
          currentLine.setAttribute("y2", y2);
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;
          const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
          const arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
          arrow.setAttribute("points", "0,-8 16,0 0,8");
          arrow.setAttribute("fill", currentLineGroup.lineColor);
          arrow.setAttribute("transform", `translate(${midX},${midY}) rotate(${angle})`);
          currentLineGroup.appendChild(arrow);
          await addLineToFirestore({ x1, y1, x2, y2, color: currentLineGroup.lineColor, midX, midY, angle });
          activeTool = null;
          lineDrawingState = 0;
          currentLine = null;
          currentLineGroup = null;
          markerLayer.style.pointerEvents = "auto";
          document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
        }
      }
      else if (activeTool === "bezier") {
        bezierControlPoints.push({ x: pt.x, y: pt.y });
        updateBezierPreview();
      }
      else if (activeTool === "polygon") {
        polygonVertices.push({ x: pt.x, y: pt.y });
        updatePolygonPreview();
      }
    }

    // Bezier helper: de Casteljau algorithm
    function calculateBezier(points, t) {
      let temp = points.map(p => ({...p}));
      for (let i = temp.length - 1; i > 0; i--) {
        for (let j = 0; j < i; j++) {
          temp[j] = {
            x: temp[j].x + (temp[j+1].x - temp[j].x) * t,
            y: temp[j].y + (temp[j+1].y - temp[j].y) * t
          };
        }
      }
      return temp[0];
    }
    
    // Helper: approximate arc-length midpoint along the bezier curve
    function getBezierArcMidpoint(controlPoints, samples = 100) {
      let pts = [];
      for (let i = 0; i <= samples; i++) {
        let t = i / samples;
        pts.push(calculateBezier(controlPoints, t));
      }
      let totalLength = 0;
      let cumulative = [0];
      for (let i = 1; i < pts.length; i++) {
        let dx = pts[i].x - pts[i-1].x;
        let dy = pts[i].y - pts[i-1].y;
        let d = Math.sqrt(dx*dx+dy*dy);
        totalLength += d;
        cumulative.push(totalLength);
      }
      let half = totalLength / 2;
      let index = cumulative.findIndex(val => val >= half);
      if (index <= 0) return pts[0];
      let d0 = cumulative[index-1];
      let d1 = cumulative[index];
      let factor = (half - d0) / (d1 - d0);
      let p0 = pts[index-1];
      let p1 = pts[index];
      return { x: p0.x + factor*(p1.x - p0.x), y: p0.y + factor*(p1.y - p0.y) };
    }

    function updateBezierPreview() {
      if (currentBezierPath) { currentBezierPath.remove(); }
      if (bezierControlPoints.length < 2) return;
      currentBezierPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      let d = "";
      const samples = 50;
      for (let i = 0; i <= samples; i++) {
        let t = i / samples;
        let pt = calculateBezier(bezierControlPoints, t);
        d += (i === 0 ? `M ${pt.x} ${pt.y}` : ` L ${pt.x} ${pt.y}`);
      }
      currentBezierPath.setAttribute("d", d);
      currentBezierPath.setAttribute("stroke", "yellow");
      currentBezierPath.setAttribute("stroke-width", "3");
      currentBezierPath.setAttribute("fill", "none");
      lineLayer.appendChild(currentBezierPath);
    }

    function updatePolygonPreview() {
      if (currentPolygonElement) { currentPolygonElement.remove(); }
      if (polygonVertices.length < 2) return;
      currentPolygonElement = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const pointsStr = polygonVertices.map(p => `${p.x},${p.y}`).join(" ");
      currentPolygonElement.setAttribute("points", pointsStr);
      currentPolygonElement.setAttribute("stroke", selectedColor);
      currentPolygonElement.setAttribute("stroke-width", "2");
      currentPolygonElement.setAttribute("fill", selectedColor);
      currentPolygonElement.setAttribute("fill-opacity", "0.3");
      lineLayer.appendChild(currentPolygonElement);
    }

    async function commitBezier() {
      if (bezierControlPoints.length < 2) return;
      if (currentBezierPath) { currentBezierPath.remove(); currentBezierPath = null; }
      // Use the globally selectedColor
      const bezierColor = selectedColor;
      
      // Create a group to hold the bezier path and its arrows
      const bezierGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");

      // Create the bezier path element
      const pathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
      let d = "";
      const samples = 100;
      for (let i = 0; i <= samples; i++) {
        let t = i / samples;
        let pt = calculateBezier(bezierControlPoints, t);
        d += (i === 0 ? `M ${pt.x} ${pt.y}` : ` L ${pt.x} ${pt.y}`);
      }
      pathElem.setAttribute("d", d);
      pathElem.setAttribute("stroke", bezierColor);
      pathElem.setAttribute("stroke-width", "3");
      pathElem.setAttribute("fill", "none");
      bezierGroup.appendChild(pathElem);

      // Arrow at the end (using t=0.98 to t=1.0)
      let pt1 = calculateBezier(bezierControlPoints, 0.98);
      let pt2 = calculateBezier(bezierControlPoints, 1.0);
      let angleEnd = Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x) * (180/Math.PI);
      const arrowEnd = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrowEnd.setAttribute("points", "0,-8 16,0 0,8");
      arrowEnd.setAttribute("fill", bezierColor);
      arrowEnd.setAttribute("transform", `translate(${pt2.x},${pt2.y}) rotate(${angleEnd})`);
      bezierGroup.appendChild(arrowEnd);

      // Calculate arc-length midpoint and arrow in the middle
      let midPt = getBezierArcMidpoint(bezierControlPoints, 100);
      let angleMid = Math.atan2(pt2.y - midPt.y, pt2.x - midPt.x) * (180/Math.PI);
      const arrowMid = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrowMid.setAttribute("points", "0,-8 16,0 0,8");
      arrowMid.setAttribute("fill", bezierColor);
      arrowMid.setAttribute("transform", `translate(${midPt.x},${midPt.y}) rotate(${angleMid})`);
      bezierGroup.appendChild(arrowMid);

      lineLayer.appendChild(bezierGroup);

      try {
        const docRef = await addDoc(collection(db, "bezierCurves"), {
          controlPoints: bezierControlPoints,
          color: bezierColor,
          timestamp: serverTimestamp(),
          owner: auth.currentUser.uid
        });
        recordAuditLog("add_bezier", { bezierId: docRef.id });
        bezierGroup.dataset.id = docRef.id;
      } catch (error) {
        console.error("Error adding bezier curve:", error);
      }
      // Attach deletion event to the entire bezier group
      bezierGroup.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (await customConfirm("Delete this bezier curve?")) {
          try {
            await deleteDoc(doc(db, "bezierCurves", bezierGroup.dataset.id));
            recordAuditLog("delete_bezier", { bezierId: bezierGroup.dataset.id });
            bezierGroup.remove();
          } catch (error) {
            console.error("Error deleting bezier curve:", error);
          }
        }
      });
      activeTool = null;
      bezierControlPoints = [];
      markerLayer.style.pointerEvents = "auto";
      document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
    }

    async function commitPolygon() {
      if (polygonVertices.length < 3) return;
      if (currentPolygonElement) { currentPolygonElement.remove(); currentPolygonElement = null; }
      const polygonElem = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const pointsStr = polygonVertices.map(p => `${p.x},${p.y}`).join(" ");
      polygonElem.setAttribute("points", pointsStr);
      polygonElem.setAttribute("stroke", selectedColor);
      polygonElem.setAttribute("stroke-width", "2");
      polygonElem.setAttribute("fill", selectedColor);
      polygonElem.setAttribute("fill-opacity", "0.3");
      lineLayer.appendChild(polygonElem);
      try {
        const docRef = await addDoc(collection(db, "polygons"), {
          vertices: polygonVertices,
          color: selectedColor,
          timestamp: serverTimestamp(),
          owner: auth.currentUser.uid
        });
        recordAuditLog("add_polygon", { polygonId: docRef.id });
        polygonElem.dataset.id = docRef.id;
      } catch (error) {
        console.error("Error adding polygon:", error);
      }
      polygonElem.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (await customConfirm("Delete this polygon?")) {
          try {
            await deleteDoc(doc(db, "polygons", polygonElem.dataset.id));
            recordAuditLog("delete_polygon", { polygonId: polygonElem.dataset.id });
            polygonElem.remove();
          } catch (error) {
            console.error("Error deleting polygon:", error);
          }
        }
      });
      activeTool = null;
      polygonVertices = [];
      markerLayer.style.pointerEvents = "auto";
      document.querySelectorAll("#toolbox .tool").forEach(t => t.style.borderColor = "rgba(223,197,136,0.5)");
    }

    async function addMarkerToFirestore(type, x, y) {
      const user = auth.currentUser;
      if (!user) { console.error("User not authenticated"); return; }
      let markerData = { type, x, y, timestamp: serverTimestamp(), owner: user.uid };
      if (["homestead", "keep", "torch", "cave", "sword", "spear", "bow", "beacon", "camp", "catapult", "ram"].includes(type)) {
        markerData.text = await customPrompt("Enter marker text:", "") || "";
        markerData.color = selectedColor;
      }
      try {
        const docRef = await addDoc(collection(db, "markers"), markerData);
        recordAuditLog("add", { markerId: docRef.id, markerType: type });
      } catch (error) {
        console.error("Error adding marker:", error);
      }
    }

    async function addLineToFirestore(lineData) {
      const user = auth.currentUser;
      if (!user) { console.error("User not authenticated"); return; }
      try {
        const docRef = await addDoc(collection(db, "lines"), {
          ...lineData,
          timestamp: serverTimestamp(),
          owner: user.uid
        });
        recordAuditLog("add_line", { lineId: docRef.id });
      } catch (error) {
        console.error("Error adding line:", error);
      }
    }

    function listenForBezierCurves() {
      const bezierQuery = query(collection(db, "bezierCurves"), orderBy("timestamp"));
      onSnapshot(bezierQuery, (snapshot) => {
        lineLayer.querySelectorAll("g[data-bezier='true']").forEach(elem => elem.remove());
        snapshot.forEach(docSnap => {
          createBezierElement(docSnap.id, docSnap.data());
        });
      });
    }

    function createBezierElement(id, data) {
      const bezierGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      bezierGroup.dataset.id = id;
      bezierGroup.setAttribute("data-bezier", "true");
      
      const pathElem = document.createElementNS("http://www.w3.org/2000/svg", "path");
      let d = "";
      const samples = 100;
      for (let i = 0; i <= samples; i++) {
        let t = i / samples;
        let pt = calculateBezier(data.controlPoints, t);
        d += (i === 0 ? `M ${pt.x} ${pt.y}` : ` L ${pt.x} ${pt.y}`);
      }
      pathElem.setAttribute("d", d);
      pathElem.setAttribute("stroke", data.color);
      pathElem.setAttribute("stroke-width", "3");
      pathElem.setAttribute("fill", "none");
      bezierGroup.appendChild(pathElem);

      let pt1 = calculateBezier(data.controlPoints, 0.98);
      let pt2 = calculateBezier(data.controlPoints, 1.0);
      let angleEnd = Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x) * (180/Math.PI);
      const arrowEnd = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrowEnd.setAttribute("points", "0,-8 16,0 0,8");
      arrowEnd.setAttribute("fill", data.color);
      arrowEnd.setAttribute("transform", `translate(${pt2.x},${pt2.y}) rotate(${angleEnd})`);
      bezierGroup.appendChild(arrowEnd);

      let midPt = getBezierArcMidpoint(data.controlPoints, 100);
      let angleMid = Math.atan2(pt2.y - midPt.y, pt2.x - midPt.x) * (180/Math.PI);
      const arrowMid = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrowMid.setAttribute("points", "0,-8 16,0 0,8");
      arrowMid.setAttribute("fill", data.color);
      arrowMid.setAttribute("transform", `translate(${midPt.x},${midPt.y}) rotate(${angleMid})`);
      bezierGroup.appendChild(arrowMid);

      bezierGroup.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (await customConfirm("Delete this bezier curve?")) {
          try {
            await deleteDoc(doc(db, "bezierCurves", id));
            recordAuditLog("delete_bezier", { bezierId: id });
            bezierGroup.remove();
          } catch (error) {
            console.error("Error deleting bezier curve:", error);
          }
        }
      });
      lineLayer.appendChild(bezierGroup);
    }

    function listenForPolygons() {
      const polyQuery = query(collection(db, "polygons"), orderBy("timestamp"));
      onSnapshot(polyQuery, (snapshot) => {
        lineLayer.querySelectorAll("polygon[data-polygon='true']").forEach(elem => elem.remove());
        snapshot.forEach(docSnap => {
          createPolygonElement(docSnap.id, docSnap.data());
        });
      });
    }

    function createPolygonElement(id, data) {
      const polygonElem = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      const pointsStr = data.vertices.map(p => `${p.x},${p.y}`).join(" ");
      polygonElem.setAttribute("points", pointsStr);
      polygonElem.setAttribute("stroke", data.color);
      polygonElem.setAttribute("stroke-width", "2");
      polygonElem.setAttribute("fill", data.color);
      polygonElem.setAttribute("fill-opacity", "0.3");
      polygonElem.dataset.id = id;
      polygonElem.setAttribute("data-polygon", "true");
      polygonElem.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (await customConfirm("Delete this polygon?")) {
          try {
            await deleteDoc(doc(db, "polygons", id));
            recordAuditLog("delete_polygon", { polygonId: id });
            polygonElem.remove();
          } catch (error) {
            console.error("Error deleting polygon:", error);
          }
        }
      });
      lineLayer.appendChild(polygonElem);
    }

    function listenForMarkers() {
      let snapshotReceived = false;
      const markersQuery = query(collection(db, "markers"), orderBy("timestamp"));
      const unsubscribe = onSnapshot(markersQuery, (snapshot) => {
        snapshotReceived = true;
        while (markerLayer.firstChild) { markerLayer.removeChild(markerLayer.firstChild); }
        snapshot.forEach((docSnap) => { createMarkerElement(docSnap.id, docSnap.data()); });
        updateMarkerVisibility();
      }, (error) => {
        console.error("Firestore connection error:", error);
        displayErrorOverlay("Firestore connection failed.");
      });
      setTimeout(() => {
        if (!snapshotReceived) { console.error("No Firestore snapshot received within timeout."); displayErrorOverlay("Firestore connection failed."); unsubscribe(); }
      }, 5000);
    }

    function listenForLines() {
      const linesQuery = query(collection(db, "lines"), orderBy("timestamp"));
      onSnapshot(linesQuery, (snapshot) => {
        lineLayer.innerHTML = "";
        snapshot.forEach((docSnap) => { createLineElement(docSnap.id, docSnap.data()); });
        updateLineVisibility();
      });
    }

    function createMarkerElement(id, data) {
      let markerEl = document.createElementNS("http://www.w3.org/2000/svg", "g");
      markerEl.setAttribute("data-marker", "true");
      markerEl.dataset.type = data.type;
      let imgSrc, imgWidth, imgHeight, imgXOffset, imgYOffset, fontSize;
      if (data.type === "homestead") {
        imgSrc = "https://regnumsolis.com/planner/images/marker.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -(imgWidth / 2); imgYOffset = -20 * 1.7; fontSize = 16 * 1.7;
      } else if (data.type === "keep") {
        imgSrc = "https://regnumsolis.com/planner/images/citadel.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      } else if (data.type === "torch") {
        imgSrc = "https://regnumsolis.com/planner/images/torch.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "cave") {
        imgSrc = "https://regnumsolis.com/planner/images/cave.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "sword") {
        imgSrc = "https://regnumsolis.com/planner/images/sword.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "spear") {
        imgSrc = "https://regnumsolis.com/planner/images/spear.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "bow") {
        imgSrc = "https://regnumsolis.com/planner/images/bow.svg";
        imgWidth = 30 * 1.7; imgHeight = 30 * 1.7;
        imgXOffset = -15 * 1.7; imgYOffset = -15 * 1.7; fontSize = 14 * 1.7;
      } else if (data.type === "beacon") {
        imgSrc = "https://regnumsolis.com/planner/images/beacon.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      } else if (data.type === "camp") {
        imgSrc = "https://regnumsolis.com/planner/images/camp.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      } else if (data.type === "catapult") {
        imgSrc = "https://regnumsolis.com/planner/images/catapult.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      } else if (data.type === "ram") {
        imgSrc = "https://regnumsolis.com/planner/images/ram.svg";
        imgWidth = 30 * 1.7 * 1.2; imgHeight = 30 * 1.7 * 1.2;
        imgXOffset = -15 * 1.7 * 1.2; imgYOffset = -15 * 1.7 * 1.2; fontSize = 14 * 1.7 * 1.2;
      }
      let textXOffset = imgXOffset + imgWidth;
      const imgEl = document.createElementNS("http://www.w3.org/2000/svg", "image");
      imgEl.setAttributeNS("http://www.w3.org/1999/xlink", "href", imgSrc);
      imgEl.setAttribute("width", imgWidth);
      imgEl.setAttribute("height", imgHeight);
      imgEl.setAttribute("x", data.x + imgXOffset);
      imgEl.setAttribute("y", data.y + imgYOffset);
      markerEl.appendChild(imgEl);
      const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      textEl.textContent = data.text;
      textEl.setAttribute("fill", data.color);
      textEl.setAttribute("font-size", fontSize);
      textEl.setAttribute("x", data.x + textXOffset);
      textEl.setAttribute("y", data.y);
      textEl.setAttribute("text-anchor", "start");
      textEl.setAttribute("dominant-baseline", "middle");
      textEl.style.fontFamily = "'Bebas Neue', sans-serif";
      markerEl.appendChild(textEl);
      requestAnimationFrame(() => {
        const bbox = textEl.getBBox();
        const textLength = textEl.getComputedTextLength();
        const rectEl = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rectEl.setAttribute("x", bbox.x);
        rectEl.setAttribute("y", bbox.y);
        rectEl.setAttribute("width", textLength);
        rectEl.setAttribute("height", bbox.height);
        rectEl.setAttribute("fill", "#1e1e1e");
        rectEl.setAttribute("opacity", "0.63");
        markerEl.insertBefore(rectEl, textEl);
      });
      markerEl.classList.add("marker");
      markerEl.dataset.id = id;
      markerEl.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (activeTool === "line" || activeTool === "bezier" || activeTool === "polygon") return;
        if (await customConfirm("Delete this marker?")) {
          try {
            await deleteDoc(doc(db, "markers", id));
            recordAuditLog("delete", { markerId: id, markerType: data.type });
            markerEl.remove();
          } catch (error) {
            console.error("Error deleting marker:", error);
          }
        }
      });
      markerLayer.appendChild(markerEl);
    }

    function createLineElement(id, data) {
      const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
      group.classList.add("line-group");
      group.dataset.id = id;
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", data.x1);
      line.setAttribute("y1", data.y1);
      line.setAttribute("x2", data.x2);
      line.setAttribute("y2", data.y2);
      line.setAttribute("stroke", data.color);
      line.setAttribute("stroke-width", "3.2");
      const arrow = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
      arrow.setAttribute("points", "0,-8 16,0 0,8");
      arrow.setAttribute("fill", data.color);
      arrow.setAttribute("transform", `translate(${data.midX},${data.midY}) rotate(${data.angle})`);
      group.appendChild(line);
      group.appendChild(arrow);
      group.addEventListener("click", async (e) => {
        e.stopPropagation();
        if (await customConfirm("Delete this line?")) {
          try {
            await deleteDoc(doc(db, "lines", id));
            recordAuditLog("delete_line", { lineId: id });
            group.remove();
          } catch (error) {
            console.error("Error deleting line:", error);
          }
        }
      });
      lineLayer.appendChild(group);
    }

    function recordAuditLog(action, details) {
      const user = auth.currentUser;
      if (!user) return;
      const logData = { action, details, user: user.email, timestamp: serverTimestamp() };
      addDoc(collection(db, "auditLogs"), logData)
        .catch(error => console.error("Error writing audit log:", error));
    }

    function listenForAuditLogs() {
      const auditContainer = document.getElementById("audit-log-container");
      const auditQuery = query(collection(db, "auditLogs"), orderBy("timestamp", "asc"));
      onSnapshot(auditQuery, (snapshot) => {
        const logs = [];
        snapshot.forEach(docSnap => {
          logs.push(docSnap.data());
        });
        const grouped = [];
        logs.forEach(log => {
          if (grouped.length === 0) {
            grouped.push({ log: log, count: 1 });
          } else {
            const lastGroup = grouped[grouped.length - 1];
            const sameAction = lastGroup.log.action === log.action;
            let sameMarkerType = true;
            if (log.action === "add" || log.action === "delete") {
              sameMarkerType = (lastGroup.log.details.markerType === log.details.markerType);
            }
            if (sameAction && sameMarkerType) {
              lastGroup.count++;
            } else {
              grouped.push({ log: log, count: 1 });
            }
          }
        });
        auditContainer.innerHTML = "";
        grouped.forEach(group => {
          const log = group.log;
          const dateStr = new Date(log.timestamp ? log.timestamp.seconds * 1000 : Date.now()).toLocaleString();
          let detailsText = "";
          if (log.details && log.details.markerType) {
            detailsText = ` (${log.details.markerType})`;
          }
          const groupCount = group.count > 1 ? ` <span class="log-group">(x${group.count})</span>` : "";
          const entry = document.createElement("div");
          entry.innerHTML = `[${dateStr}] <span class="log-user">${log.user}</span> <span class="log-action">${log.action}${detailsText}</span>${groupCount}`;
          auditContainer.appendChild(entry);
        });
      });
    }

    function getSVGPoint(e) {
      const pt = svgRoot.createSVGPoint();
      pt.x = e.clientX; pt.y = e.clientY;
      return pt.matrixTransform(panLayer.getScreenCTM().inverse());
    }

    function displayErrorOverlay(message) {
      const overlay = document.getElementById("error-overlay");
      overlay.textContent = message;
      overlay.style.display = "flex";
      console.warn("Error overlay activated:", message);
    }
  </script>
  <script>
    function customPrompt(message, defaultValue) {
      return new Promise((resolve) => {
        const overlay = document.getElementById("custom-prompt-overlay");
        const promptMessage = document.getElementById("custom-prompt-message");
        const promptInput = document.getElementById("custom-prompt-input");
        const okButton = document.getElementById("custom-prompt-ok");
        const cancelButton = document.getElementById("custom-prompt-cancel");
        promptMessage.textContent = message;
        promptInput.value = defaultValue || "";
        promptInput.style.display = "block";
        overlay.style.display = "flex";
        promptInput.focus();
        function cleanup() {
          overlay.style.display = "none";
          okButton.removeEventListener("click", onOk);
          cancelButton.removeEventListener("click", onCancel);
          promptInput.removeEventListener("keydown", onKeyDown);
        }
        function onOk() { resolve(promptInput.value); cleanup(); }
        function onCancel() { resolve(null); cleanup(); }
        function onKeyDown(e) { if (e.key === "Enter") { onOk(); } }
        okButton.addEventListener("click", onOk);
        cancelButton.addEventListener("click", onCancel);
        promptInput.addEventListener("keydown", onKeyDown);
      });
    }
  </script>
  <script>
    function customConfirm(message) {
      return new Promise((resolve) => {
        const overlay = document.getElementById("custom-prompt-overlay");
        const promptMessage = document.getElementById("custom-prompt-message");
        const promptInput = document.getElementById("custom-prompt-input");
        const okButton = document.getElementById("custom-prompt-ok");
        const cancelButton = document.getElementById("custom-prompt-cancel");
        promptMessage.textContent = message;
        promptInput.style.display = "none";
        overlay.style.display = "flex";
        function cleanup() {
          overlay.style.display = "none";
          promptInput.style.display = "block";
          okButton.removeEventListener("click", onOk);
          cancelButton.removeEventListener("click", onCancel);
        }
        function onOk() { resolve(true); cleanup(); }
        function onCancel() { resolve(false); cleanup(); }
        okButton.addEventListener("click", onOk);
        cancelButton.addEventListener("click", onCancel);
      });
    }
  </script>
  <script>
    // WebGL background shader setup restored
    const canvas = document.getElementById('waveCanvas');
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight;
    const gl = canvas.getContext("webgl");
    if (!gl) { alert("WebGL is not supported in your browser."); }

    const vertexShaderSource = `
      attribute vec2 a_position;
      varying vec2 v_uv;
      void main() {
        v_uv = a_position * 0.5 + 0.5;
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;
    const fragmentShaderSource = `
      precision mediump float;
      uniform float u_time;
      uniform vec2 u_resolution;
      varying vec2 v_uv;
      float wave(vec2 st, float angle, float frequency, float amplitude, float speed) {
        vec2 dir = vec2(cos(angle), sin(angle));
        float phaseOffset = angle * 7.0;
        return sin(dot(st, dir) * frequency + u_time * speed + phaseOffset) * amplitude;
      }
      float waveHeight(vec2 st) {
        float h = 0.0;
        h += wave(st, 0.0, 30.1, 0.0020, 0.81);
        h += wave(st, 0.7, 40.3, 0.0017, 0.63);
        h += wave(st, 1.4, 55.7, 0.0010, 1.04);
        h += wave(st, 2.1, 65.2, 0.0012, 0.91);
        h += wave(st, 2.8, 50.5, 0.0015, 1.12);
        h += wave(st, 3.3, 60.9, 0.0013, 0.87);
        h += wave(st, 4.0, 45.6, 0.0014, 1.05);
        h += wave(st, 4.7, 70.8, 0.0011, 0.99);
        return h;
      }
      vec3 computeNormal(vec2 st, float h) {
        float eps = 0.001;
        float hx = waveHeight(st + vec2(eps, 0.0));
        float hy = waveHeight(st + vec2(0.0, eps));
        float dFdx = (hx - h) / eps;
        float dFdy = (hy - h) / eps;
        return normalize(vec3(-dFdx, -dFdy, 1.0));
      }
      void main(){
        vec2 st = gl_FragCoord.xy / u_resolution.xy;
        st.y *= u_resolution.y / u_resolution.x;
        float h = waveHeight(st);
        vec3 normal = computeNormal(st, h);
        vec3 deepWater = vec3(0.0, 0.15, 0.35);
        vec3 shallowWater = vec3(0.0, 0.45, 0.75);
        vec3 baseColor = mix(deepWater, shallowWater, st.y + h * 0.5);
        vec3 sunDir = normalize(vec3(0.3, 0.8, 1.0));
        float diffuse = max(dot(normal, sunDir), 0.0);
        vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));
        vec3 halfDir = normalize(sunDir + viewDir);
        float spec = pow(max(dot(normal, halfDir), 0.0), 50.0);
        float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0) * 0.6;
        vec3 color = baseColor * (0.4 + 0.6 * diffuse) + vec3(1.0, 0.95, 0.8) * spec;
        color = mix(color, vec3(1.0), fresnel);
        color *= 0.1;
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)){
        console.error("Shader compile error: ", gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
        console.error("Program link error: ", gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);
    gl.useProgram(program);

    const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [
      -1, -1,
      1, -1,
      -1, 1,
      -1, 1,
      1, -1,
      1, 1,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
    const timeUniformLocation = gl.getUniformLocation(program, "u_time");

    function render(time) {
      time *= 0.001;
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
      gl.uniform1f(timeUniformLocation, time);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>
</html>
